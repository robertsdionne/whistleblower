// main global script file

// Called when the game starts, before the first room is loaded
function game_start() {
  mouse.Mode = eModePointer;
  WorkPrevButton1.Enabled = false;
  WorkNextButton11.Enabled = false;
  WorkDenyButton1.Enabled = false;
  WorkApproveButton1.Enabled = false;
  WorkDenyButton2.Enabled = false;
  WorkApproveButton2.Enabled = false;
  WorkDenyButton3.Enabled = false;
  WorkApproveButton3.Enabled = false;
  WorkDenyButton4.Enabled = false;
  WorkApproveButton4.Enabled = false;
}


function repeatedly_execute() {
  // Put here anything you want to happen every game cycle, even when
  // the game is paused. This will not run when the game is blocked
  // inside a command like a blocking Walk()
  
  if (IsGamePaused() == 1) return;

  // Put here anything you want to happen every game cycle, but not
  // when the game is paused.
}


function repeatedly_execute_always() {
  // Put anything you want to happen every game cycle, even
  // when the game is blocked inside a command like a
  // blocking Walk().
  // You cannot run blocking commands from this function.  
}


function LoginButton_OnClick(GUIControl *control, MouseButton button) {
  MaybeLogin();
}


function show_inventory_window() {
  Inventory.Visible = true;
  // switch to the Use cursor (to select items with)
  mouse.Mode = eModeInteract;
  // But, override the appearance to look like the arrow
  mouse.UseModeGraphic(eModePointer);
}


function on_event(EventType event, int data) {
  if (eEventGUIMouseDown == event && 1 != data) {
    Type.Play();
  }
}


// Called when a key is pressed. keycode holds the key's ASCII code
function on_key_press(eKeyCode keycode) {
  Type.Play();
  // The following is called before "if game is paused keycode=0", so
  // it'll happen even when the game is paused.

  if (IsGamePaused() || (IsInterfaceEnabled() == 0)) {
    // If the game is paused with a modal GUI on the
    // screen, or the player interface is disabled in
    // a cut scene, ignore any keypresses.
    return;
  }

  // FUNCTION KEYS AND SYSTEM SHORTCUTS
  if (keycode == eKeyEscape) {
    // ESC
    mouse.UseModeGraphic(eModePointer);
  }
  if (keycode == eKeyCtrlQ)  QuitGame(1);   // Ctrl-Q
  if (keycode == eKeyF12) SaveScreenShot("scrnshot.bmp");  // F12
}


function on_mouse_click(MouseButton button) {
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  if (IsGamePaused() == 1) {
    // Game is paused, so do nothing (ie. don't allow mouse click)
  }
  else if (button == eMouseLeft) {
    ProcessClick(mouse.x, mouse.y, mouse.Mode );
  }
  else if (button == eMouseRight || button == eMouseWheelSouth){
    // right-click our mouse-wheel down, so cycle cursor
    mouse.SelectNextMode();
  }
  else if (button == eMouseMiddle) { 
    // Middle-button-click, default make character walk to clicked area (a little shortcut)
    // Could have been just "player.Walk(mouse.x,mouse.y)", but it's best to
    // leave our options open - what if you have a special script triggered
    // on "walking" mode?
    ProcessClick(mouse.x, mouse.y, eModeWalkto); 
  }
  else if (button == eMouseWheelNorth) { 
    // Mouse-wheel up, cycle cursors 
    // If mode isn't WALK, set the previous mode (notice usage of numbers instead
    // of eNums, when it suits us)...
    if (mouse.Mode>0) mouse.Mode=mouse.Mode-1; 
    else 
    { 
      // ...but if it is WALK mode...
      if (player.ActiveInventory!=null) 
      {
        //...and the player has a selected inventory item, set mouse mode to UseInv. 
        mouse.Mode=eModeUseinv; 
      }
      else 
      {
        // If they don't, however, just set it to mode TALK (change this line if you add more cursor modes)
        mouse.Mode=eModeTalkto; 
      }
    }
  }
}


function interface_click(int interface, int button) {
  // This function is obsolete, from 2.62 and earlier versions.
}


function btnInvUp_Click(GUIControl *control, MouseButton button) {
  invCustomInv.ScrollUp();
}


function btnInvDown_Click(GUIControl *control, MouseButton button) {
  invCustomInv.ScrollDown();
}


function btnInvOK_Click(GUIControl *control, MouseButton button) {
	// They pressed the OK button, close the GUI
	Inventory.Visible = false;
	mouse.UseDefaultGraphic();
}


function btnInvSelect_Click(GUIControl *control, MouseButton button) {
	// They pressed SELECT, so switch to the Get cursor
	mouse.Mode = eModeInteract;
	// But, override the appearance to look like the arrow
	mouse.UseModeGraphic(eModePointer);
}


function btnIconInv_Click(GUIControl *control, MouseButton button) {
  show_inventory_window();
}


function btnIconCurInv_Click(GUIControl *control, MouseButton button) {
  if (player.ActiveInventory != null)
    mouse.Mode = eModeUseinv;
}


function cEgo_Look() {
  Display("Damn, I'm looking good!");
}


function cEgo_Interact() {
  Display("You rub your hands up and down your clothes.");
}


function cEgo_Talk() {
  Display("Talking to yourself is a sign of madness!");
}


function dialog_request(int param)  {
  // This is used by the dialog text parser if you need to process
  // text that the player types in to the parser.
  // It is not used by default.
}


function CloseButton_OnClick(GUIControl *control, MouseButton button) {
  control.OwningGUI.Visible = false;
}


function Raise_OnClick(GUI *theGui, MouseButton button) {
  Raise(theGui);
}


function RaiseMail_OnClick(GUI *theGui, MouseButton button) {
  Raise(Mail1);
  Mail2.ZOrder = z_index;
}


function SwitchMail(GUIControl *control, GUI *next) {
  CloseButton_OnClick(control, eMouseLeft);
  Mail = next;
  Mail.Visible = true;
}


function MailNextButton1_OnClick(GUIControl *control, MouseButton button) {
  SwitchMail(control, Mail2);
}


function MailPrevButton2_OnClick(GUIControl *control, MouseButton button) {
  SwitchMail(control, Mail1);
}


function SwitchWork(GUIControl *control, GUI *next) {
  CloseButton_OnClick(control, eMouseLeft);
  Work = next;
  Work.Visible = true;
}


function WorkNextButton1_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work2);
}


function WorkPrevButton2_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work1);
}


function WorkNextButton2_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work3);
}


function WorkPrevButton3_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work2);
}


function WorkNextButton3_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work4);
}


function WorkPrevButton4_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work3);
}


function WorkNextButton4_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work5);
}


function WorkPrevButton5_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work4);
}


function WorkNextButton5_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work6);
}

function WorkPrevButton6_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work5);
}


function WorkNextButton6_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work7);
}


function WorkPrevButton7_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work6);
}

function WorkNextButton7_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work8);
}


function WorkPrevButton8_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work7);
}


function WorkNextButton8_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work9);
}


function WorkPrevButton9_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work8);
}


function WorkNextButton9_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work10);
}


function WorkPrevButton10_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work9);
}


function WorkNextButton10_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control,  Work11);
}


function WorkPrevButton11_OnClick(GUIControl *control, MouseButton button) {
  SwitchWork(control, Work10);
}


function TicketPrintButton_OnClick(GUIControl *control, MouseButton button) {
  Print.PlayQueued();
  TicketPrintButton.Enabled = false;
  Display("Ticket Printed.");
}


function Chat_OnClick(GUI *theGui, MouseButton button) {
  theGui.LockView(HORACE);
  theGui.Animate(0, 5, eOnce, eBlock, eForwards);
  theGui.Animate(1, 5, eRepeat, eNoBlock, eForwards);
  Intro.Start();
}


function ChatCloseButton_OnClick(GUIControl *control, MouseButton button) {
  control.OwningGUI.LockView(HORACE);
  control.OwningGUI.Animate(0, 5, eOnce, eBlock, eBackwards);
  CloseButton_OnClick(control, button);
}


function Chat2_OnClick(GUI *theGui,  MouseButton button) {
  theGui.LockView(JUSTIN);
  theGui.Animate(0, 5, eOnce, eBlock, eForwards);
  theGui.Animate(1, 5, eRepeat, eNoBlock, eForwards);
  Intro.Start();
}


function ChatCloseButton2_OnClick(GUIControl *control, MouseButton button) {
  control.OwningGUI.LockView(JUSTIN);
  control.OwningGUI.Animate(0, 5, eOnce, eBlock, eBackwards);
  CloseButton_OnClick(control, button);
}


function WorkDenyButton_OnClick(GUIControl *control, MouseButton button) {
  control.OwningGUI.Controls[3].Enabled = false;
  control.OwningGUI.Controls[4].Enabled = false;
  control.OwningGUI.Controls[5].AsLabel.TextColor = 49152;
  control.OwningGUI.Controls[5].AsLabel.Text = "Denied";
  denied += 1;
  WorkDeniedSummaryLabel.Text = String.Format("%d", denied);
}


function WorkApproveButton_OnClick(GUIControl *control, MouseButton button) {
  control.OwningGUI.Controls[3].Enabled = false;
  control.OwningGUI.Controls[4].Enabled = false;
  control.OwningGUI.Controls[5].AsLabel.TextColor = 2016;
  control.OwningGUI.Controls[5].AsLabel.Text = "Approved";
  approved += 1;
  WorkApprovedSummaryLabel.Text = String.Format("%d", approved);
}
